<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on gmetal&#39;s dev blog</title>
        <link>https://gmetal.dev/posts/</link>
        <description>Recent content in Posts on gmetal&#39;s dev blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 18 Jan 2022 08:00:00 +0000</lastBuildDate>
        <atom:link href="https://gmetal.dev/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Avoid Long Apply in Variable Initialisations</title>
            <link>https://gmetal.dev/posts/avoid-long-apply-in-variable-init/</link>
            <pubDate>Tue, 18 Jan 2022 08:00:00 +0000</pubDate>
            
            <guid>https://gmetal.dev/posts/avoid-long-apply-in-variable-init/</guid>
            <description>The apply scope function is a very useful Kotlin standard library method for grouping long variable configuration blocks, when no builder is available. It can be used when creating functions that return the instance of the object (in a builder like fashion), like in the following code:
class MyClass { fun func(): MyClass = apply { // add code here  } } Moreover, it is especially convenient when using older APIs which do not provide a builder.</description>
            <content type="html"><![CDATA[<p>The <a href="https://kotlinlang.org/docs/scope-functions.html#apply">apply</a> scope function is a very useful Kotlin standard library method for grouping long variable configuration blocks, when no builder is available. It can be used when creating functions that return the instance of the object (in a builder like fashion), like in the following code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
  <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">func</span>(): MyClass = apply {
    <span style="color:#75715e">// add code here
</span><span style="color:#75715e"></span>  }
}
</code></pre></div><p>Moreover, it is especially convenient when using older APIs which do not provide a builder. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
  <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">func</span>(person: Person, friendList: List&lt;String&gt;) {
    <span style="color:#66d9ef">val</span> bunde = Bundle().apply {
      putString(<span style="color:#e6db74">&#34;name&#34;</span>, person.fullName
      putInt(<span style="color:#e6db74">&#34;age&#34;</span>, person.age)
      putBoolean(<span style="color:#e6db74">&#34;isActive&#34;</span>, person.isActive)
      putStringList(<span style="color:#e6db74">&#34;friends&#34;</span>, ArrayList&lt;String&gt;(friendList))
    }
  }
}
</code></pre></div><p>Thus, it provides a means of creating and initialising a complex object in a <code>val</code> property of a class. In order words, you can do something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>(person: Person, friendList: List&lt;String&gt;) {
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> myBundle: Bundle = Bundle().apply {
      putString(<span style="color:#e6db74">&#34;name&#34;</span>, person.fullName
      putInt(<span style="color:#e6db74">&#34;age&#34;</span>, person.age)
      putBoolean(<span style="color:#e6db74">&#34;isActive&#34;</span>, person.isActive)
      putStringList(<span style="color:#e6db74">&#34;friends&#34;</span>, ArrayList&lt;String&gt;(friendList))
    }
}
</code></pre></div><p>However, often in development, when the requirements change and different (although not always) developers update the same piece of code, there is often little attention paid to minor code quality degradation. For example, consider updating the above example with code to add more filtering in the <code>friendsList</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>(person: Person, friendList: List&lt;String&gt;) {
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> myBundle: Bundle = Bundle().apply {
      putString(<span style="color:#e6db74">&#34;name&#34;</span>, person.fullName
      putInt(<span style="color:#e6db74">&#34;age&#34;</span>, person.age)
      putBoolean(<span style="color:#e6db74">&#34;isActive&#34;</span>, person.isActive)
      putStringList(
        <span style="color:#e6db74">&#34;friends&#34;</span>, 
        friendList.filter { <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">it</span> }
            .map {
                <span style="color:#66d9ef">it</span>.split(<span style="color:#e6db74">&#34; &#34;</span>)
                    .zipWithNext()
                    .map { pair <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${pair.second}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${pair.first}</span><span style="color:#e6db74">&#34;</span> }
            }
            .flatten()
            .fold(ArrayList&lt;String&gt;()) { acc, item <span style="color:#f92672">-&gt;</span>
                acc.add(item)
                acc
            }
      )
    }
}
</code></pre></div><p>Then someone might naively attempt to extract the <code>friendsList</code> filtering into an external method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>(person: Person, friendList: List&lt;String&gt;) {
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> myBundle: Bundle = Bundle().apply {
      putString(<span style="color:#e6db74">&#34;name&#34;</span>, person.fullName
      putInt(<span style="color:#e6db74">&#34;age&#34;</span>, person.age)
      putBoolean(<span style="color:#e6db74">&#34;isActive&#34;</span>, person.isActive)
      filterFriendsList(friendsList)
    }

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">filterFriendsList</span>(friendList: List&lt;String&gt;) {
        myBundle.putStringList(
          <span style="color:#e6db74">&#34;friends&#34;</span>, 
          friendList.filter { <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">it</span> }
              .map {
                  <span style="color:#66d9ef">it</span>.split(<span style="color:#e6db74">&#34; &#34;</span>)
                      .zipWithNext()
                      .map { pair <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${pair.second}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${pair.first}</span><span style="color:#e6db74">&#34;</span> }
              }
              .flatten()
              .fold(ArrayList&lt;String&gt;()) { acc, item <span style="color:#f92672">-&gt;</span>
                  acc.add(item)
                  acc
              }
      )
    }
}
</code></pre></div><p>Now this method extraction has introduced a very simple <code>NullPointerException</code> bug, one which may surprise you somewhat when running the code. It is certainly non-obvious and easily missed, especially if you&rsquo;ve been on top of the code for a while. Running the above snippet throws a <code>NullPointerException</code> in the following line:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">myBundle.putStringList(
</code></pre></div><p>The variable <code>myBundle</code> is null. Although at first this may be confusing it has a very simple explanation. Let&rsquo;s focus on this line here:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> myBundle: Bundle = Bundle().apply {
</code></pre></div><p>When a new <code>MyClass</code> object is created, the <code>myBundle</code> variable will have to be initialised. This initialisation is achieved by creating a new <code>Bundle</code> object, then running the <code>apply</code> block on the newly created object and then taking the result and assigning it to the <code>myBundle</code> variable. So the code of the <code>filterFriendsList</code> would work as it was written previously, because it was executing in the context of the newly created <code>Bundle</code> object, but cannot work as is without the <code>myBundle</code> instance having been initialised first.</p>
<p>There are multiple solutions to this problem. Do not forget that it was introduced by adding excessive logic in the variable initialisation, inside the <code>apply</code> block. Therefore the simplest solution is to extract all the initialisation logic in a separate function. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>(person: Person, friendList: List&lt;String&gt;) {
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> myBundle: Bundle = createMyBundle(person, friendList)

  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">createMyBundle</span>(person: Person, friendList: List&lt;String&gt;): Bundle {
      <span style="color:#66d9ef">val</span> bundle = Bundle()
      bundle.putString(<span style="color:#e6db74">&#34;name&#34;</span>, person.fullName
      bundle.putInt(<span style="color:#e6db74">&#34;age&#34;</span>, person.age)
      bundle.putBoolean(<span style="color:#e6db74">&#34;isActive&#34;</span>, person.isActive)
      bundle.putStringList(
          <span style="color:#e6db74">&#34;friends&#34;</span>, 
          friendList.filter { <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">it</span> }
              .map {
                  <span style="color:#66d9ef">it</span>.split(<span style="color:#e6db74">&#34; &#34;</span>)
                      .zipWithNext()
                      .map { pair <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${pair.second}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${pair.first}</span><span style="color:#e6db74">&#34;</span> }
              }
              .flatten()
              .fold(ArrayList&lt;String&gt;()) { acc, item <span style="color:#f92672">-&gt;</span>
                  acc.add(item)
                  acc
              }
      )
      <span style="color:#66d9ef">return</span> person
    }
}
</code></pre></div><p>Now all the code needed is in a single function, it is clear that it creates a new object instance, and it can be further refactored as needed in the future.</p>
]]></content>
        </item>
        
        <item>
            <title>Unit Testing WithTimeout in Coroutines With Kotest</title>
            <link>https://gmetal.dev/posts/unit-testing-withtimeout-with-kotest/</link>
            <pubDate>Wed, 03 Nov 2021 08:01:49 +0000</pubDate>
            
            <guid>https://gmetal.dev/posts/unit-testing-withtimeout-with-kotest/</guid>
            <description>Sometimes you may be required to implement code that executes periodic actions. In Java, you can implement such a feature using a Timer. Kotlin also provided a wrapper for this, using the fixedRateTimer function. The above mentioned method of creating a timer is old-style, thread-based and JVM specific. Coroutines offer a better solution for solving this problem, in a more lightweight, efficient and cross-platform manner. One such more-kotlin styled approach, is provided by the ticker, which is part of the Channels API.</description>
            <content type="html"><![CDATA[<p>Sometimes you may be required to implement code that executes periodic actions. In Java, you can implement such a feature using a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Timer.html">Timer</a>. Kotlin also provided a wrapper for this, using the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.concurrent/fixed-rate-timer.html">fixedRateTimer</a> function. The above mentioned method of creating a timer is old-style, thread-based and JVM specific. Coroutines offer a better solution for solving this problem, in a more lightweight, efficient and cross-platform manner. One such more-kotlin styled approach, is provided by the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html">ticker</a>, which is part of the Channels API. However, this approach is currently marked as <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-obsolete-coroutines-api/index.html">ObsoleteCoroutinesApi</a>, and may be subject to change.</p>
<h2 id="a-suspendable-coroutine-based-timer-implementation">A suspendable, coroutine-based Timer implementation</h2>
<p>It is not very difficult to create a custom implementation of the Timer functionality, while also leveraging the power of Kotlin coroutines. This can be based on the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a> and the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a> functions. The <code>withTimeout</code> function runs a given block until the specified timeout. If the timeout is not exceeded, then it exists normally. However, if the timeout is exceeded, it throws a <code>TimeoutCancellationException</code>. The <code>delay</code> function will suspend the current coroutine until the specified amount of time has passed.</p>
<p>Using the abovementioned suspending functions, a trivial timer implementation can be implemented:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CoroutineTimer</span>(
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> period: Long = <span style="color:#ae81ff">1000L</span>,
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> repeat: Boolean = <span style="color:#66d9ef">false</span>,
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> dispatcher: CoroutineDispatcher = Dispatchers.Default,
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> timerAction: () <span style="color:#f92672">-&gt;</span> Unit
) {
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> job: Job? = <span style="color:#66d9ef">null</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Starts the execution of the timer
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Synchronized</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">start</span>() {
        <span style="color:#66d9ef">if</span> (isRunning()) {
            <span style="color:#66d9ef">return</span>
        }

        job = CoroutineScope(dispatcher).launch {
            withTimeout(period) {
                delay(period + <span style="color:#ae81ff">1</span>)
            }
        }.also {
            <span style="color:#66d9ef">it</span>.invokeOnCompletion { exc <span style="color:#f92672">-&gt;</span>
                <span style="color:#66d9ef">when</span> (exc) {
                    <span style="color:#66d9ef">is</span> TimeoutCancellationException <span style="color:#f92672">-&gt;</span> {
                        <span style="color:#75715e">// Timeout reached, execute the action and reschedule if required
</span><span style="color:#75715e"></span>                        timerAction()
                        <span style="color:#66d9ef">if</span> (repeat) {
                            start()
                        }
                    }
                    <span style="color:#66d9ef">is</span> CancellationException <span style="color:#f92672">-&gt;</span> {
                        <span style="color:#75715e">// The stop method was called and I&#39;ve been cancelled
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// Ignore
</span><span style="color:#75715e"></span>                    }
                    <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> {
                        <span style="color:#75715e">// Unknown exception received
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// Ignore
</span><span style="color:#75715e"></span>                    }
                }
            }
        }
    }

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Stops the execution of the timer, if it is running
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">stop</span>() {
        job<span style="color:#f92672">?.</span>cancel(CancellationException())
    }

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Returns whether the timer is currently running or not
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">isRunning</span>(): Boolean = job<span style="color:#f92672">?.</span>isActive <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div><p>Let&rsquo;s dive into the code. The <code>CoroutineTimer</code> class, takes 4 arguments in its constructor:</p>
<ul>
<li>the period of execution in milliseconds</li>
<li>whether the timer is repeatable or once-off</li>
<li>the CoroutineDispatcher to use while waiting (is to better support tests)</li>
<li>the action to execute, as a non-suspending lambda that takes no arguments and returns no value (obviously this can be modified accordingly)</li>
</ul>
<div class="admonition note">
<p class="admonition title">Note</p>
<p>Specifying the coroutine dispatcher in the constructor of our class (with the desired default implementation) allows us to control it in our tests. It is currently considered a best practice. A good source of information about this approach can be found <a href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices">here</a>.</p>
</div>

<p>The timer has two states, started and stopped. It is initiallised in the stopped state and can be controlled with the following methods:</p>
<ul>
<li>the <code>start</code> method starts the timer, when it is not running. If the timer is already running, it will not be started again.</li>
<li>the <code>stop</code> method stops the timer</li>
<li>the <code>isRunning</code> method returns whether the timer is currently running or not. When the timer is started, it is considered to be running, whereas when it is stopped, it is not considered as running. In case the timer is used in an once-off fashion, after the action has executed, the timer is considered to be stopped (i.e. not running).</li>
</ul>
<p>The core functionality has been implemented in the <code>start</code> method. Internally, it launches a new coroutine that uses the <code>withTimeout</code> function for the timer. Inside the <code>withTimeout</code>, the code uses the suspending <code>delay</code> function, to delay until the timeout is reached. When the timeout is reached, a <code>TimeoutCancellationException</code> is thrown by the <code>withTimeout</code> function. In case, the timer is cancelled, then a <code>CancellationException</code> will be thrown (by the <code>stop</code> method). The code will inspect the result of the coroutine, with the help of the <code>invokeOnCompletion</code>, and if the timeout was reached, it will execute the action and then proceed to reschedule the next execution of the code (if the timer is repeatable). To determine whether the timer is running and to support the timer cancellation, a reference to the <code>Job</code> object returned by <code>launch</code> function is maintained.</p>
<h2 id="unit-testing-the-implementation-with-junit---the-naive-way">Unit testing the implementation with JUnit - the naive way</h2>
<p>Testing multithreading code is always a challenging task. In our case, we have two main test cases:</p>
<ul>
<li>the timer action is executed after the timer has elapsed (exactly once when the <code>repeat</code> flag is not set, or multiple times when it is set)</li>
<li>the timer action is not executed when the timer is cancelled before it is elapsed</li>
</ul>
<p>The naive approach would be to:</p>
<ul>
<li>use a mock timer action for testing if it is executed or not</li>
<li>use a small timer interval and carefully timed <code>sleeps</code> for waiting until the timer elapses</li>
</ul>
<div class="admonition note">
<p class="admonition title">Note</p>
<p>A  <code>sleep</code> refers to an invocation of the <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Thread.html#sleep(long)">java.lang.Thread.sleep()</a> method, that will make the current thread temporarily pause, for the specified time interval in milliseconds. It is often a cheap, and inefficient way to wait for a bit before continuing to perform a task. It is rarely a good programming practice and is JVM specific.</p>
</div>

<p>There are significant shortcomings with blocking the test with the <code>sleeps</code> method  until the timer elapses. First of all, the sleeps must be carefully timed, or you may end up having non-deterministic test outcomes, due to the non-deterministic nature of thread scheduling. Blocking the thread that executes your test, increases your overall test execution time (and unit tests must not take too long). In more complex situations, using sleeps will become very difficult to manage.</p>
<p>If we had to write our tests using this inefficient manner, let&rsquo;s see how this could be done (using <a href="https://junit.org/junit5/docs/current/user-guide/">JUnit 5</a> and <a href="https://mockk.io">Mockk</a>). First of all, we want to test that when the <code>repeat</code> flag is false and the timer is started, the action will be executed after the timer has elapsed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#a6e22e">@Timeout</span>(<span style="color:#ae81ff">3500</span>, unit = TimeUnit.MILLISECONDS)
    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">without_repeat_calling_start_will_execute_the_timer_action_once</span>() {
        <span style="color:#66d9ef">val</span> testCoroutineTimer = CoroutineTimer(<span style="color:#ae81ff">2000</span>, <span style="color:#66d9ef">false</span>, timerAction = mockTimerAction)

        testCoroutineTimer.start()

        assertEquals(<span style="color:#66d9ef">true</span>, testCoroutineTimer.isRunning())
        <span style="color:#66d9ef">while</span> (testCoroutineTimer.isRunning()) {
            sleep(<span style="color:#ae81ff">1000</span>)
        }
        assertEquals(<span style="color:#66d9ef">false</span>, testCoroutineTimer.isRunning())
        verify { mockTimerAction.invoke() }
    }
</code></pre></div><p>The above test creates a new non-repeatable <code>CoroutineTimer</code>, with a time period of 2000 msec, which will execute the mockTimerAction. It proceeds to start the timer, verify that it is running, and then sleep until the timer stops running. When this happens, the test is concluded by verifying that the mock timer action was executed. Currently, the test runs successfully. But what would happen if while updating the code, a bug is introduced in the <code>isRunning</code> method and it always reports that the timer is running. In this case, the test would fall into an infinite loop. To cater for this eventuality, the JUnit5 <a href="https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Timeout.html">Timeout annotation</a> was added, which instructs the test runner to terminate the test execution after the specified time interval elapses.</p>
<p>To test that if the timer action is not executed when the timer is cancelled, we can use the following test:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#a6e22e">@Timeout</span>(<span style="color:#ae81ff">3500</span>, unit = TimeUnit.MILLISECONDS)
    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">without_repeat_calling_stop_will_stop_the_timer_without_executing_the_timer_action</span>() {
        <span style="color:#66d9ef">val</span> testCoroutineTimer = CoroutineTimer(<span style="color:#ae81ff">2000</span>, <span style="color:#66d9ef">false</span>, timerAction = mockTimerAction)

        testCoroutineTimer.start()
        sleep(<span style="color:#ae81ff">1000</span>)
        assertEquals(<span style="color:#66d9ef">true</span>, testCoroutineTimer.isRunning())
        testCoroutineTimer.stop()

        <span style="color:#66d9ef">while</span> (testCoroutineTimer.isRunning()) {
            sleep(<span style="color:#ae81ff">1000</span>)
        }
        assertEquals(<span style="color:#66d9ef">false</span>, testCoroutineTimer.isRunning())
        verify { mockTimerAction wasNot called }
    }
</code></pre></div><p>In the above test, the timer is initialised with a large enough period, such that when the <code>stop</code> method is called, the timer will not have expired. The <code>isRunning</code> checks after the test must still be performed, because <code>stop</code> may not be instantaneous. Again, to avoid waiting forever for the timer to stop, the <code>Timeout</code> JUnit 5 annotation is used.</p>
<p>To test the multiple execution of the timer action (i.e. the repeat flag is set to true), the following test can be used:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">with_repeat_wait_to_execute_twice_and_then_stop</span>() {
        <span style="color:#66d9ef">val</span> testCoroutineTimer = CoroutineTimer(<span style="color:#ae81ff">2000</span>, <span style="color:#66d9ef">true</span>, timerAction = mockTimerAction)

        testCoroutineTimer.start()
        sleep(<span style="color:#ae81ff">2100</span>)
        assertEquals(<span style="color:#66d9ef">true</span>, testCoroutineTimer.isRunning())
        verify(atLeast = <span style="color:#ae81ff">1</span>, atMost = <span style="color:#ae81ff">1</span>) { mockTimerAction.invoke() }
        sleep(<span style="color:#ae81ff">2100</span>)
        testCoroutineTimer.stop()
        verify(atLeast = <span style="color:#ae81ff">2</span>, atMost = <span style="color:#ae81ff">2</span>) { mockTimerAction.invoke() }

        assertEquals(<span style="color:#66d9ef">false</span>, testCoroutineTimer.isRunning())
    }
</code></pre></div><p>The above test starts the timer, sleeps until the timer expires once, and then sleeps a bit more to verify that the timer expires again. Finally, it stops the timer execution and verifies that the timer has stopped.</p>
<h2 id="unit-testing-the-implementation-with-junit---the-coroutine-way">Unit testing the implementation with JUnit - the coroutine way</h2>
<p>Coroutines are a more advanced, modern and fine grained tool for achieving concurrency. As such, they include much better testing support, which can be found in the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/">kotlinx-coroutines-test artifact</a>. The main testing functionalities provided by the package are the following:</p>
<ul>
<li>The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/index.html">TestCoroutineDispatcher</a> which executes tasks synchronously, but also allows the developer to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/index.html">control the dispatcher&rsquo;s internal clock</a>.</li>
<li>Controlling the Dispatchers.Main dispatcher, using the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/reset-main.html">Dispatchers.resetMain</a> functions.</li>
<li>The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-blocking-test.html">runBlockingTest function</a>, which executes a test by bypassing any delays introduced by <code>async</code> and <code>launch</code> and skipping the calls to <code>delay</code>. In essence, this is similar to the <code>runBlocking</code> coroutine builder function.</li>
</ul>
<p>Armed with the abovementioned tools, we can rewrite our tests so that:</p>
<ul>
<li>they are much more manageable</li>
<li>they use the provided coroutine tools</li>
<li>they run faster
There are several general guidelines that will assist you in effectively testing coroutine code. First of all, you should always <code>inject</code> the dispatcher in use. You should also provide the desired dispatcher as a default value. Using this simple tip, allows you to override the dispatcher in your tests with the <code>TestCoroutineDispatcher</code>. Also, your test functions should always contain a single <code>runBlockingTest</code> call, with the test code inside. The <code>runBlockingTest</code> can use a predefined coroutine dispatcher, allowing you to easily control its internal clock. Finally, it is essentially a coroutine builder function allowing you to call other suspend functions immediately.</li>
</ul>
<div class="admonition important">
<p class="admonition title">Warning</p>
<p>The majority of the coroutine testing tools are currently marked as <code>@ExperimentalCoroutinesApi</code>, which means that their API is subject to change. You will have to explicitly enable them in your tests.</p>
</div>

<p>First of all, we declare an instance of the TestCoroutineDispatcher in our test class, which we recreate before each test. This Dispatcher will give us access to the coroutine&rsquo;s internal clock (e.g. move time forward!). Next, we wrap the body of the three aforementioned tests, inside a <code>runBlockingTest</code> call, such that we eliminate delays from <code>async</code> and <code>launch</code>. We also pass the reference of our TestCoroutineDispatcher to the <code>runBlockingTest</code> method, and also inject this dispatcher to our Timer class, such that they both use the same CoroutineContext (we are thus able to call the <code>advanceTimeBy</code> inside the body of our test, rather than explicitly on the test dispatcher). Finally, we replace the <code>sleep</code> related calls, with calls to <code>advanceTimeBy</code> (and remove any loops we may have been using).</p>
<p>Consequently, the first test becomes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#a6e22e">@Timeout</span>(<span style="color:#ae81ff">3500</span>, unit = TimeUnit.MILLISECONDS)
    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">without_repeat_calling_start_will_execute_the_timer_action_once</span>() = runBlockingTest(testCoroutineDispatcher) {
        <span style="color:#66d9ef">val</span> testCoroutineTimer = CoroutineTimer(<span style="color:#ae81ff">2000</span>, <span style="color:#66d9ef">false</span>, testCoroutineDispatcher, mockTimerAction)

        testCoroutineTimer.start()

        assertEquals(<span style="color:#66d9ef">true</span>, testCoroutineTimer.isRunning())
        advanceTimeBy(<span style="color:#ae81ff">2100</span>)

        assertEquals(<span style="color:#66d9ef">false</span>, testCoroutineTimer.isRunning())
        verify { mockTimerAction.invoke() }
    }
</code></pre></div><p>The second test becomes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#a6e22e">@Timeout</span>(<span style="color:#ae81ff">3500</span>, unit = TimeUnit.MILLISECONDS)
    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">without_repeat_calling_stop_will_stop_the_timer_without_executing_the_timer_action</span>() = runBlockingTest(testCoroutineDispatcher) {
        <span style="color:#66d9ef">val</span> testCoroutineTimer = CoroutineTimer(<span style="color:#ae81ff">2000</span>, <span style="color:#66d9ef">false</span>, testCoroutineDispatcher, mockTimerAction)

        testCoroutineTimer.start()
        advanceTimeBy(<span style="color:#ae81ff">1000</span>)
        assertEquals(<span style="color:#66d9ef">true</span>, testCoroutineTimer.isRunning())
        testCoroutineTimer.stop()
        advanceTimeBy(<span style="color:#ae81ff">1500</span>)

        assertEquals(<span style="color:#66d9ef">false</span>, testCoroutineTimer.isRunning())
        verify { mockTimerAction wasNot called }
    }
</code></pre></div><p>And finally, the third test becomes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">with_repeat_wait_to_execute_twice_and_then_stop</span>() = runBlockingTest(testCoroutineDispatcher) {
        <span style="color:#66d9ef">val</span> testCoroutineTimer = CoroutineTimer(<span style="color:#ae81ff">2000</span>, <span style="color:#66d9ef">true</span>, testCoroutineDispatcher, mockTimerAction)

        testCoroutineTimer.start()
        advanceTimeBy(<span style="color:#ae81ff">2100</span>)
        assertEquals(<span style="color:#66d9ef">true</span>, testCoroutineTimer.isRunning())
        verify(atLeast = <span style="color:#ae81ff">1</span>, atMost = <span style="color:#ae81ff">1</span>) { mockTimerAction.invoke() }
        advanceTimeBy(<span style="color:#ae81ff">2100</span>)
        testCoroutineTimer.stop()
        verify(atLeast = <span style="color:#ae81ff">2</span>, atMost = <span style="color:#ae81ff">2</span>) { mockTimerAction.invoke() }

        assertEquals(<span style="color:#66d9ef">false</span>, testCoroutineTimer.isRunning())
    }
</code></pre></div><h2 id="unit-testing-the-implementation-with-kotest">Unit testing the implementation with Kotest</h2>
<p><a href="https://kotest.io/">Kotest</a> is a more modern testing framework for Kotlin. It makes heavy use of coroutines for its implementation, and therefore includes first-class support for them. For example, you can unit test <code>suspend</code> functions without enclosing them in <code>runBlocking</code> or <code>runBlockingTest</code> calls. In the upcoming 5.0.0 release there will be support for the <a href="https://github.com/kotest/kotest/pull/2550">TestCoroutinDispatcher</a>, which is currently available in the 5.0.0.M3 snapshot release.</p>
<p>The changes required for the conversion of the tests to the Kotest library, can be found <a href="https://github.com/gmetal/coroutine-timer/commit/d5b5bc74528039df8c08c0b6f35acd3fa282dc31">here</a>. One of the great advantages of Kotest is that it supports using multiple testing styles. The unit tests of the CoroutineTimer were converted to the BehaviorSpec testing style. The <code>TestCoroutineDispatcher</code> in Kotest is exported through the [DelayController interface]{https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/index.html}. We can enable it (along with a default timeout of all test cases) in our Kotest BehaviorSpec tests, with the following code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@ExperimentalStdlibApi</span>
<span style="color:#a6e22e">@ExperimentalKotest</span>
<span style="color:#a6e22e">@ExperimentalCoroutinesApi</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CoroutineTimerTest</span> : BehaviorSpec({
    <span style="color:#75715e">// Sets per-test case timeout for all test cases in the spec
</span><span style="color:#75715e"></span>    timeout = <span style="color:#ae81ff">3500</span>
    <span style="color:#75715e">// Enable the TestCoroutineDispatcher
</span><span style="color:#75715e"></span>    testCoroutineDispatcher = <span style="color:#66d9ef">true</span>
</code></pre></div><p>To get access to the coroutine dispatcher in use you can use the following code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">coroutineContext[CoroutineDispatcher.Key]
</code></pre></div><p>Kotest uses the TestCoroutineDispatcher in the current <code>coroutineContext</code>, which can be acquired through the <code>CoroutineDispatcher.Key</code>. Thus we can create an initialisation function like the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">setupTest</span>(repeat: Boolean, coroutineContext: CoroutineContext) {
        mockTimerAction = mockk()
        every { mockTimerAction.invoke() } just Runs

        testCoroutineTimer = CoroutineTimer(
            <span style="color:#ae81ff">2000</span>,
            repeat,
            timerAction = mockTimerAction,
            dispatcher = coroutineContext[CoroutineDispatcher.Key]<span style="color:#f92672">!!</span>
        )
    }
</code></pre></div><p>In our tests we need not use the <code>runBlockingTest</code> function call like before. In order to adjust the internal coroutine dispatcher timer, Kotest exposes the <code>delayController</code> property of the TestContext. Apart from the different testing style introduced, very little needs to be changed, in comparison with the JUnit approach and the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/">kotlinx-coroutines-test artifact</a>. Thus the tests can be rewritten:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">Given(<span style="color:#e6db74">&#34;a CoroutineTimer&#34;</span>) {
    And(<span style="color:#e6db74">&#34;the timer executes once&#34;</span>) {
        And(<span style="color:#e6db74">&#34;the timer is running&#34;</span>) {
            When(<span style="color:#e6db74">&#34;the timer is executed&#34;</span>) {
                setupTest(repeat = <span style="color:#66d9ef">false</span>, testContext.coroutineContext)
                 testCoroutineTimer.start()
                <span style="color:#66d9ef">val</span> timerWasRunning = testCoroutineTimer.isRunning()

                delayController.advanceTimeBy(<span style="color:#ae81ff">2100</span>)

                Then(<span style="color:#e6db74">&#34;the timer was running&#34;</span>) {
                    timerWasRunning shouldBe <span style="color:#66d9ef">true</span>
                }
                Then(<span style="color:#e6db74">&#34;the timer stops running&#34;</span>) {
                    testCoroutineTimer.isRunning() shouldBe <span style="color:#66d9ef">false</span>
                }
                Then(<span style="color:#e6db74">&#34;the timerAction is executed once&#34;</span>) {
                    verify(atMost = <span style="color:#ae81ff">1</span>, atLeast = <span style="color:#ae81ff">1</span>) { mockTimerAction.invoke() }
                }
            }
            When(<span style="color:#e6db74">&#34;the timer is stopped&#34;</span>) {
                setupTest(repeat = <span style="color:#66d9ef">false</span>, testContext.coroutineContext)
                testCoroutineTimer.start()

                delayController.advanceTimeBy(<span style="color:#ae81ff">1000</span>)

                <span style="color:#66d9ef">val</span> timerWasRunning = testCoroutineTimer.isRunning()

                 testCoroutineTimer.stop()
                delayController.advanceTimeBy(<span style="color:#ae81ff">1500</span>)

                Then(<span style="color:#e6db74">&#34;verify the time was running&#34;</span>) {
                    timerWasRunning shouldBe <span style="color:#66d9ef">true</span>
                }
                Then(<span style="color:#e6db74">&#34;the timer stops running&#34;</span>) {
                    assertEquals(<span style="color:#66d9ef">false</span>, testCoroutineTimer.isRunning())
                }
                Then(<span style="color:#e6db74">&#34;the timer actions is not executed&#34;</span>) {
                    verify { mockTimerAction wasNot called }
                }
            }
        }
    }
    And(<span style="color:#e6db74">&#34;the timer executes indefinitely&#34;</span>) {
        When(<span style="color:#e6db74">&#34;a single time period has elapsed&#34;</span>) {
            setupTest(repeat = <span style="color:#66d9ef">true</span>, testContext.coroutineContext)
            testCoroutineTimer.start()
            delayController.advanceTimeBy(<span style="color:#ae81ff">2100</span>)
            <span style="color:#66d9ef">val</span> timerWasRunning = testCoroutineTimer.isRunning()
            delayController.advanceTimeBy(<span style="color:#ae81ff">2100</span>)

            testCoroutineTimer.stop()

            Then(<span style="color:#e6db74">&#34;the timer was running&#34;</span>) {
                timerWasRunning shouldBe <span style="color:#66d9ef">true</span>
            }
            Then(<span style="color:#e6db74">&#34;the timer action has executed twice&#34;</span>) {
                verify(atLeast = <span style="color:#ae81ff">2</span>, atMost = <span style="color:#ae81ff">2</span>) { mockTimerAction.invoke() }
            }
            Then(<span style="color:#e6db74">&#34;the timer is not running&#34;</span>) {
                testCoroutineTimer.isRunning() shouldBe <span style="color:#66d9ef">false</span>
            }
        }
    }}
})
</code></pre></div><h2 id="benchmarking-the-different-test-implementations">Benchmarking the different test implementations</h2>
<p>To benchmark the performance gains of using the <code>kotlinx-coroutine-test</code> means of testing versus the traditional <code>sleep</code> approach versus the Kotest implementation, the tests were executed 10 times with each different approach. The tables below summarises the results, which show that the tests using the coroutine tools were significantly faster.</p>
<table>
<thead>
<tr>
<th>Run iteration</th>
<th>Test w/h Sleeps</th>
<th>Test with Coroutines</th>
<th>Test with Kotest</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>10.878</td>
<td>2.452</td>
<td>0.022</td>
</tr>
<tr>
<td>2</td>
<td>10.813</td>
<td>2.416</td>
<td>0.017</td>
</tr>
<tr>
<td>3</td>
<td>10.916</td>
<td>2.805</td>
<td>0.025</td>
</tr>
<tr>
<td>4</td>
<td>10.865</td>
<td>2.263</td>
<td>0.013</td>
</tr>
<tr>
<td>5</td>
<td>10.890</td>
<td>2.771</td>
<td>0.016</td>
</tr>
<tr>
<td>6</td>
<td>10.948</td>
<td>2.727</td>
<td>0.021</td>
</tr>
<tr>
<td>7</td>
<td>10.894</td>
<td>2.641</td>
<td>0.019</td>
</tr>
<tr>
<td>8</td>
<td>10.906</td>
<td>2.785</td>
<td>0.037</td>
</tr>
<tr>
<td>9</td>
<td>10.905</td>
<td>2.694</td>
<td>0.021</td>
</tr>
<tr>
<td>10</td>
<td>10.912</td>
<td>2.330</td>
<td>0.024</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>Test w/h Sleeps</th>
<th>Test with Coroutines</th>
<th>Test with Kotest</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVG</td>
<td>10.890</td>
<td>2.617</td>
<td>0.024</td>
</tr>
<tr>
<td>MEDIAN</td>
<td>10.894</td>
<td>2.694</td>
<td>0.021</td>
</tr>
</tbody>
</table>
<p>The tests executed with Kotest were blazingly fast. It is worth pointing out, that on the machine were the tests were run, it took a bit more than 2 seconds to initialise the JUnit coroutine test suite. This time was added in the first test executed. This means, that excluding the test initialisation, the tests using coroutine tools took milliseconds to complete, making them comparable to the Kotest tests. Clearly, using coroutines results in code which is much cleaner, more testable and much faster.</p>
]]></content>
        </item>
        
        <item>
            <title>Using kotest in your Android project</title>
            <link>https://gmetal.dev/posts/using-kotest/</link>
            <pubDate>Sat, 28 Aug 2021 16:00:00 +0000</pubDate>
            
            <guid>https://gmetal.dev/posts/using-kotest/</guid>
            <description>Android Studio Unit Testing Support by compscigrad is licensed under CC BY-NC-SA 2.0
  Kotest is a Kotlin multiplatform testing framework and assertions library. It is a powerful framework, that can completely replace the default kotlin test framework, which is based on the popular JUnit and TestNG. Furthermore, Kotest supports some more advanced features, such as property-based testing and its own assertions framework.
An interesting question may be why would anyone use kotest over the standard, popular JUnit (for example) framework?</description>
            <content type="html"><![CDATA[<figure>
    <img src="/images/17999323626_9a0ee192aa_o.jpg"/> <figcaption>
            <p>
                    <a href="https://www.flickr.com/photos/48784629@N00/17999323626">Android Studio Unit Testing Support by compscigrad is licensed under CC BY-NC-SA 2.0</a></p>
        </figcaption>
</figure>

<p><a href="https://kotest.io/">Kotest</a> is a Kotlin multiplatform testing framework and assertions library. It is a powerful framework, that can completely replace the default <a href="https://kotlinlang.org/api/latest/kotlin.test/">kotlin test</a> framework, which is based on the popular <a href="https://junit.org/">JUnit</a> and <a href="https://testng.org/">TestNG</a>. Furthermore, Kotest supports some more advanced features, such as <a href="https://kotest.io/docs/proptest/property-based-testing.html">property-based testing</a> and its own <a href="https://kotest.io/docs/assertions/assertions.html">assertions framework</a>.</p>
<p>An interesting question may be why would anyone use kotest over the standard, popular JUnit (for example) framework? The main reasons are the following:</p>
<ul>
<li>kotest has built-in support for coroutines</li>
<li>it offers its own expressive assertions library</li>
<li>it has a multitude of extensions that bring all sorts of goodies in</li>
<li>it supports many different <a href="https://kotest.io/docs/framework/testing-styles.html">testing styles</a></li>
</ul>
<h2 id="configuring-kotest-in-your-android-project">Configuring Kotest in your Android project</h2>
<p>I had been using JUnit5 in one of my hobby projects, the <a href="https://github.com/gmetal/metador">metador library</a>, and I wanted to replace it with kotest. The instructions found in the Android section of the <a href="https://kotest.io/docs/quickstart">kotest quickstart</a> are pretty well written, can even guide into installing some of the most advanced features. I opted for the <a href="https://kotest.io/docs/assertions/assertions.html">assertions library</a> and the <a href="https://kotest.io/docs/extensions/mockserver.html">mockserver extension</a>, in order to replace the okhttp mock webserver implementation I had been using.</p>
<p>Therefore, the following dependencies were added in the module&rsquo;s build.gradle:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">    testImplementation <span style="color:#e6db74">&#34;io.kotest:kotest-runner-junit5:$kotestVersion&#34;</span>
    testImplementation <span style="color:#e6db74">&#34;io.kotest:kotest-assertions-core:$kotestVersion&#34;</span>
    testImplementation <span style="color:#e6db74">&#34;io.kotest.extensions:kotest-extensions-mockserver:1.0.0&#34;</span>
</code></pre></div><p>together with a <code>testOptions</code> in the <code>android</code> section of the module&rsquo;s build gradle:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">    testOptions <span style="color:#f92672">{</span>
        unitTests<span style="color:#f92672">.</span><span style="color:#a6e22e">all</span> <span style="color:#f92672">{</span>
            useJUnitPlatform<span style="color:#f92672">()</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>to instruct Kotest to use the underlying junit platform.</p>
<h2 id="choosing-a-kotest-test-style---using-behavior-specs">Choosing a Kotest test style - Using Behavior Specs</h2>
<p>This post discusses the use of the <a href="https://kotest.io/docs/framework/testing-styles.html#behavior-spec">Behaviour Spec</a> testing style, one of Kotest&rsquo;s many supported styles. Its greatest advanced is that it enforces an order in the tests, and makes the test output readable and almost documentation-like. It is the tools used for <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Behaviour Driven Development</a>. The tests follow a specific scenario-driven narrative using the following structure:</p>
<pre><code>Given: the initial context at the beginning of the scenario, in one or more clauses;
When: the event that triggers the scenario;
Then: the expected outcome, in one or more clauses.
</code></pre><p>Kotest offers the <code>Given</code>, <code>And</code>, <code>When</code>, <code>Then</code> functions that support the above structure. These functions are used in a nested fashion (<code>And</code> has been added to offer an additional level of nesting if required). There are also corresponding lowercase functions, but since <code>when</code> is a Kotlin-reserved keyword and requires backticks, the uppercase functions seem to be a better alternative.</p>
<p>The nesting functionality of the BehaviorSpec impacts how certain features have been implemented. If you&rsquo;ve been using JUnit (4 or 5), then you should be familiar with the <a href="https://www.baeldung.com/junit-before-beforeclass-beforeeach-beforeall">@Before, @After, @BeforeEach, @AfterEach</a> annotations. They are used for marking specific functions to be called before and after the unit tests. Kotest offers similar functionality using <code>before</code> and <code>after</code> prefixed function blocks. These functions are:</p>
<ul>
<li>beforeAny/afterAny - executed before/after any container or a test (any of the <code>Given</code>, <code>When</code>, <code>And</code>, <code>Then</code> functions). Any such block will be executed before/after the function that follows</li>
<li>beforeEach/afterEach - executed before/after a test case (the <code>Then</code> function). Any such block will be executed before/after the test case that follows</li>
<li>beforeContainer/afterContainer - executed before/after a container (one of the <code>Given</code>, <code>When</code>, <code>And</code> functions). Any such block will be executed before/after the container that follows</li>
<li>beforeTest/afterTest - executed before/after a test case (the <code>Then</code> function). Any such block will be executed before/after the test case that follows</li>
<li>beforeSpec/afterSpec - executed before/after each spec (e.g. after the execution of a Spec subclass)</li>
</ul>
<p>To better understand how the before/after functions work (and when they are executed), you can have a go at running the following example BehaviorSpec, which includes all the before/after functions at various levels:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ContainerExampleTest</span> : BehaviorSpec({
    beforeContainer {
        println(<span style="color:#e6db74">&#34;Inside the root beforeContainer&#34;</span>)
    }
    afterContainer {
        println(<span style="color:#e6db74">&#34;After the root beforeContainer&#34;</span>)
    }
    println(<span style="color:#e6db74">&#34;Before the root Given&#34;</span>)

    beforeSpec {
        println(<span style="color:#e6db74">&#34;Inside the root beforeSpec&#34;</span>)
    }

    afterSpec {
        println(<span style="color:#e6db74">&#34;Inside the root afterSpec&#34;</span>)
    }

    beforeAny {
        println(<span style="color:#e6db74">&#34;Inside the root beforeAny&#34;</span>)
    }

    afterAny {
        println(<span style="color:#e6db74">&#34;Inside the root afterAny&#34;</span>)
    }

    beforeEach {
        println(<span style="color:#e6db74">&#34;Inside the root beforeEach&#34;</span>)
    }

    afterEach {
        println(<span style="color:#e6db74">&#34;Inside the root afterEach&#34;</span>)
    }

    Given(<span style="color:#e6db74">&#34;a String&#34;</span>) {
        <span style="color:#66d9ef">val</span> aString = <span style="color:#e6db74">&#34;asdf&#34;</span>
        beforeContainer {
            println(<span style="color:#e6db74">&#34;Inside the beforeContainer for: And the String is 4 characters long&#34;</span>)
        }
        afterContainer {
            println(<span style="color:#e6db74">&#34;Inside the afterContainer for: And the String is 4 characters long&#34;</span>)
        }
        println(<span style="color:#e6db74">&#34;Inside the: Given a String&#34;</span>)

        And(<span style="color:#e6db74">&#34;the String is 4 characters long&#34;</span>) {
            beforeContainer {
                println(<span style="color:#e6db74">&#34;Inside the beforeContainer for: And the toUpperCase method is called&#34;</span>)
            }
            afterContainer {
                println(<span style="color:#e6db74">&#34;Inside the afterContainer for: And the toUpperCase method is called&#34;</span>)
            }
            println(<span style="color:#e6db74">&#34;Inside the: And the String is 4 characters long&#34;</span>)

            When(<span style="color:#e6db74">&#34;the toUpperCase method is called&#34;</span>) {
                beforeTest {
                    println(<span style="color:#e6db74">&#34;Inside the beforeTest for: Then it returns the string in all caps&#34;</span>)
                }
                afterTest {
                    println(<span style="color:#e6db74">&#34;Inside the afterTest for:  Then it returns the string in all caps&#34;</span>)
                }
                println(<span style="color:#e6db74">&#34;Inside the: When the toUpperCase method is called&#34;</span>)
                <span style="color:#66d9ef">val</span> result = aString.toUpperCase()
                Then(<span style="color:#e6db74">&#34;it returns the string in all caps&#34;</span>) {
                    println(<span style="color:#e6db74">&#34;Inside the: Then it returns the string in all caps&#34;</span>)

                    result shouldBe <span style="color:#e6db74">&#34;ASDF&#34;</span>
                }
            }
            When(<span style="color:#e6db74">&#34;length property is called&#34;</span>) {
                beforeTest {
                    println(<span style="color:#e6db74">&#34;Inside the beforeTest for: Then it returns 4&#34;</span>)
                }
                afterTest {
                    println(<span style="color:#e6db74">&#34;Inside the afterTest for: Then it returns 4&#34;</span>)
                }
                println(<span style="color:#e6db74">&#34;Inside the: When length property is called&#34;</span>)

                <span style="color:#66d9ef">val</span> result = aString.length
                Then(<span style="color:#e6db74">&#34;it returns 4&#34;</span>) {
                    println(<span style="color:#e6db74">&#34;Inside the: Then it returns 4&#34;</span>)
                    result shouldBe <span style="color:#ae81ff">4</span>
                }
            }
        }
    }
})

</code></pre></div><p>Running the above test produces the following output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
Before the root Given
Inside the root beforeSpec

Inside the root beforeContainer
Inside the root beforeAny

Inside the: Given a String

Inside the root beforeContainer
Inside the root beforeAny
Inside the beforeContainer for: And the String is 4 characters long
Inside the: And the String is 4 characters long

Inside the root beforeContainer
Inside the root beforeAny
Inside the beforeContainer for: And the String is 4 characters long
Inside the beforeContainer for: And the toUpperCase method is called
Inside the: When the toUpperCase method is called

Inside the root beforeAny
Inside the root beforeEach
Inside the beforeTest for: Then it returns the string in all caps
Inside the: Then it returns the string in all caps
Inside the root afterAny
Inside the root afterEach
Inside the afterTest for:  Then it returns the string in all caps

After the root beforeContainer
Inside the root afterAny
Inside the afterContainer for: And the String is 4 characters long
Inside the afterContainer for: And the toUpperCase method is called


Inside the root beforeContainer
Inside the root beforeAny
Inside the beforeContainer for: And the String is 4 characters long
Inside the beforeContainer for: And the toUpperCase method is called
Inside the: When length property is called

Inside the root beforeAny
Inside the root beforeEach
Inside the beforeTest for: Then it returns 4
Inside the: Then it returns 4
Inside the root afterAny
Inside the root afterEach
Inside the afterTest for: Then it returns 4

After the root beforeContainer
Inside the root afterAny
Inside the afterContainer for: And the String is 4 characters long
Inside the afterContainer for: And the toUpperCase method is called

After the root beforeContainer
Inside the root afterAny
Inside the afterContainer for: And the String is 4 characters long

After the root beforeContainer
Inside the root afterAny

Inside the root afterSpec

</code></pre></div><p>In any container, where you would want to execute the same code before each of the following containers of the same level, you would want to use a <code>beforeContainer</code> function. Be careful with the nesting of the <code>beforeContainer</code> and the <code>afterContainer</code> functions. All <code>beforeContainer</code> methods found in the tree leading towards the root node will be executed, as can be seen by the preceeding exaxmple. To group code that will be executed before the actual test cases (the <code>Then</code> function calls) use <code>beforeTest</code> and <code>afterTest</code>. These two sets of functions should cover the majority of your needs, in regards to executing code before and after tests.</p>
<h2 id="migrating-existing-tests">Migrating existing tests</h2>
<p>The process of migrating existing unit tests to Kotest is pretty straight forward. Just select the testing style that works best for you, and apply it to all of your unit tests. Migrating to the BehaviorSpec style however, requires a bit more work especially in the beginning, in order to figure out how Kotest works and what is the approach to use.</p>
<p>If you&rsquo;ve been writing tests for some time, you should have heard about the simple <a href="https://java-design-patterns.com/patterns/arrange-act-assert/">arrange, act, assert</a> pattern. This is a very simplistic &ldquo;design pattern&rdquo; which suggests that you should be splitting your unit tests in three distinct parts:</p>
<ul>
<li>the arrange part: contains all statements required for setting up the test (e.g. setting the internal state of the test object and its dependencies)</li>
<li>the act part: contains all the statements required for executing the test. This should be limited to a few statements (usually no more than one or two)</li>
<li>the assert part: contains all the statements required for verifying the result of the test</li>
</ul>
<p>Tests adhering to the above pattern can be easily converted. The structure of a BehaviorSpec test usually consists of one or more <code>Given</code> function calls, which contain one or more <code>And</code> or <code>When</code> nested function calls. <code>And</code> function calls may include nested <code>When</code> or <code>Then</code> function calls. <code>When</code> function calls may in turn contain <code>And</code> or <code>Then</code> function calls. Finally, <code>Then</code> function calls do not contain any other nested functions - they are at the bottom of the chain. Thus the following are valid examples of nesting function calls in BehaviorSpec tests:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">Given {
    When {
        Then {

        }
    }
}
Given {
    And {
        When {
            Then {

            }
        }
    }
}
Given {
    And {
        Then {

        }
    }
}
Given {
    And {
        When {
            And {
                Then {

                }
            }
        }
    }
}
</code></pre></div><p><code>Then</code> blocks are always the inner-most nested elements, and are thus the natural containers of all the <strong>assert-related statements</strong>. All <strong>act-related statements</strong> must be placed in the exact preceding <code>And</code> or <code>When</code> block of the corresponding <code>Then</code>. Thus, <strong>arrange-related statements</strong> will be placed inside <code>Given</code>, <code>When</code> or <code>And</code> blocks, which must precede the <strong>act-related</strong> and <strong>assert-related</strong> statements. Because of the nesting implementation of BehaviorSpec tests, and because we want to avoid duplicating the initialisation parts of our tests, we should be placing our <strong>arrange-related statements</strong> inside <code>beforeContainer</code> blocks, such that they are executed before each of the nested <code>When</code>, <code>And</code> blocks.</p>
<h2 id="basic-example">Basic example</h2>
<p>Let&rsquo;s have a look at a few actual examples of unit tests converted to BehaviorSpec. The code (and conversion history) can be found <a href="https://github.com/gmetal/metador">here</a>. The example below presents a very basic unit test. The class to be tested, does not use any external dependencies (hence no mocking is required) and has only a single function that is exposed with very simple signature.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@ExperimentalCoroutinesApi</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HtmlMetaExtractorTest</span> {
    <span style="color:#66d9ef">lateinit</span> <span style="color:#66d9ef">var</span> htmlMetaExtractorInTest: HtmlMetaExtractor

    <span style="color:#a6e22e">@BeforeEach</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">setup</span>() {
        htmlMetaExtractorInTest = HtmlMetaExtractor()
    }

    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`empty string inputs, produce a success with an empty map`</span>() = runBlockingTest {
        <span style="color:#66d9ef">val</span> response = htmlMetaExtractorInTest.parseResource(<span style="color:#e6db74">&#34;&#34;</span>)

        assertThat(response, _is(emptyMap()))
    }

    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`an HTML input where the meta key attribute cannot be determined, produces an empty map`</span>() =
        runBlockingTest {
            <span style="color:#66d9ef">val</span> response =
                htmlMetaExtractorInTest.parseResource(HTML_DOCUMENT_WITH_UNKNOWN_ATTRIBUTE_META)

            assertThat(response, _is(emptyMap()))
        }

    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`an HTML input with all supported the meta key attributes, produces a map with entries for each meta element`</span>() =
        runBlockingTest {
            <span style="color:#66d9ef">val</span> response =
                htmlMetaExtractorInTest.parseResource(HTML_DOCUMENT_WITH_ALL_SUPPORTED_TYPES_META)

            assertThat(
                response,
                _is(
                    mapOf(
                        <span style="color:#e6db74">&#34;key-1&#34;</span> to <span style="color:#e6db74">&#34;value&#34;</span>,
                        <span style="color:#e6db74">&#34;key-2&#34;</span> to <span style="color:#e6db74">&#34;value&#34;</span>,
                        <span style="color:#e6db74">&#34;key-3&#34;</span> to <span style="color:#e6db74">&#34;value&#34;</span>
                    )

                )
            )
        }
}
</code></pre></div><p>Let&rsquo;s dissect the code of the above unit test class, and discuss how it can be converted to BehaviorSpec. First of all, when porting our code to the Kotest framework, we stop worrying about coroutines - no need for <code>@ExperimentalCoroutinesApi</code> and for littering all our test cases with <code>runBlocking</code>, as it supports coroutines natively. We may need to use the <code>TestCoroutineDispatcher</code>, if we require passing the coroutine dispatcher as a parameter to on of our method calls.</p>
<p>Next, (and since the code will be ported to BehaviorSpec) the <code>@BeforeEach</code> <code>setup</code> function will be replaced with an appropriate <code>beforeContainer</code> method call, which will still be responsible for reinitialising the object in test, before the test is executed. These tests have a merged <code>arrange-act</code> section, which will be directly moved inside a <code>When</code> block. The assertions will be moved inside a <code>Then</code> block, and be replaced with the appropriate Kotest assertions.</p>
<p>The converted test is the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> io.kotest.core.spec.style.BehaviorSpec
<span style="color:#66d9ef">import</span> io.kotest.matchers.shouldBe

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HtmlMetaExtractorTest</span> : BehaviorSpec({
    <span style="color:#66d9ef">lateinit</span> <span style="color:#66d9ef">var</span> htmlMetaExtractorInTest: HtmlMetaExtractor

    beforeContainer {
        htmlMetaExtractorInTest = HtmlMetaExtractor()
    }

    Given(<span style="color:#e6db74">&#34;an HtmlMetaExtractor&#34;</span>) {
        When(<span style="color:#e6db74">&#34;it attempts to parse an empty string resource&#34;</span>) {
            <span style="color:#66d9ef">val</span> response = htmlMetaExtractorInTest.parseResource(<span style="color:#e6db74">&#34;&#34;</span>)

            Then(<span style="color:#e6db74">&#34;it returns an empty map&#34;</span>) {
                response shouldBe emptyMap()
            }
        }

        When(<span style="color:#e6db74">&#34;the HTML input contains an unknown META key attribute&#34;</span>) {
            <span style="color:#66d9ef">val</span> response =
                htmlMetaExtractorInTest.parseResource(HTML_DOCUMENT_WITH_UNKNOWN_ATTRIBUTE_META)

            Then(<span style="color:#e6db74">&#34;it returns an empty map&#34;</span>) {
                response shouldBe emptyMap()
            }
        }

        When(<span style="color:#e6db74">&#34;the HTML input contains supported META key attributes&#34;</span>) {
            <span style="color:#66d9ef">val</span> response =
                htmlMetaExtractorInTest.parseResource(HTML_DOCUMENT_WITH_ALL_SUPPORTED_TYPES_META)
            Then(<span style="color:#e6db74">&#34;it returns a map containing all META key-value pairs&#34;</span>) {
                response shouldBe mapOf(<span style="color:#e6db74">&#34;key-1&#34;</span> to <span style="color:#e6db74">&#34;value&#34;</span>, <span style="color:#e6db74">&#34;key-2&#34;</span> to <span style="color:#e6db74">&#34;value&#34;</span>, <span style="color:#e6db74">&#34;key-3&#34;</span> to <span style="color:#e6db74">&#34;value&#34;</span>)
            }
        }
    }
})
</code></pre></div><h2 id="a-more-advanced-example">A more advanced example</h2>
<p>A more complex example unit test conversion is presented below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#a6e22e">@ExperimentalCoroutinesApi</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourceParserTest</span> {
    <span style="color:#a6e22e">@MockK</span>
    <span style="color:#66d9ef">lateinit</span> <span style="color:#66d9ef">var</span> mockResourceParserDelegate: ResourceParserDelegate

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">lateinit</span> <span style="color:#66d9ef">var</span> objectInTest: ResourceParser

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> testCoroutineDispatcher = TestCoroutineDispatcher()

    <span style="color:#a6e22e">@BeforeEach</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">setup</span>() {
        MockKAnnotations.<span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">this</span>)
        objectInTest = ResourceParser(testCoroutineDispatcher)
    }

    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`the resource parser delegates it&#39;s work to the supplied ResourceParserDelegate and returns the result to the caller`</span>() =
        runBlockingTest {
            <span style="color:#66d9ef">val</span> fakeResource = <span style="color:#e6db74">&#34;fake_resource&#34;</span>
            <span style="color:#66d9ef">val</span> expectedResult = mapOf(<span style="color:#e6db74">&#34;key&#34;</span> to <span style="color:#e6db74">&#34;value&#34;</span>)
            every { mockResourceParserDelegate.parseResource(fakeResource) } returns expectedResult

            <span style="color:#66d9ef">val</span> result = objectInTest.parseResource(mockResourceParserDelegate, fakeResource)

            verify { mockResourceParserDelegate.parseResource(fakeResource) }
            assertThat(result, _is(expectedResult))
        }

    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`exceptions thrown by the ResourceParserDelegate are propagated to the caller`</span>() =
        runBlockingTest {
            <span style="color:#66d9ef">val</span> fakeResource = <span style="color:#e6db74">&#34;fake_resource&#34;</span>
            every { mockResourceParserDelegate.parseResource(fakeResource) } throws RuntimeException(
                <span style="color:#e6db74">&#34;Error&#34;</span>
            )

            assertThrows&lt;RuntimeException&gt; {
                objectInTest.parseResource(mockResourceParserDelegate, fakeResource)
            }
        }
}
</code></pre></div><p>This test requires a few more advanced features. Firstly, it requires the use of the <code>TestCoroutineDispatcher</code> - because it has an external dependency on the <code>CoroutineDispatcher</code> to be used for executing the code. It also requires using a mock to establish that a particular scenario leads to executing a specific method of the mock. Finally, it makes use of an assertion that determines whether a specific code path throws an exception and how that is handled.</p>
<p>A potential conversion of the tests shown above, to the BehaviorSpec in Kotest is the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourceParserTest</span> : BehaviorSpec({
    <span style="color:#66d9ef">lateinit</span> <span style="color:#66d9ef">var</span> mockResourceParserDelegate: ResourceParserDelegate
    <span style="color:#66d9ef">lateinit</span> <span style="color:#66d9ef">var</span> objectInTest: ResourceParser
    <span style="color:#66d9ef">val</span> testCoroutineDispatcher = TestCoroutineDispatcher()

    beforeContainer {
        mockResourceParserDelegate = mockk()
        objectInTest = ResourceParser(testCoroutineDispatcher)
    }

    Given(<span style="color:#e6db74">&#34;a ResourceParser&#34;</span>) {
        <span style="color:#66d9ef">val</span> fakeResource = <span style="color:#e6db74">&#34;fake_resource&#34;</span>
        When(<span style="color:#e6db74">&#34;it is requested to parse a resource&#34;</span>) {
            <span style="color:#66d9ef">val</span> expectedResult = mapOf(<span style="color:#e6db74">&#34;key&#34;</span> to <span style="color:#e6db74">&#34;value&#34;</span>)
            every { mockResourceParserDelegate.parseResource(fakeResource) } returns expectedResult

            <span style="color:#66d9ef">val</span> result = objectInTest.parseResource(mockResourceParserDelegate, fakeResource)
            Then(<span style="color:#e6db74">&#34;it produces the result by delegating its work to the supplied ResourceParserDelegate&#34;</span>) {
                verify { mockResourceParserDelegate.parseResource(fakeResource) }
                result shouldBe expectedResult
            }
        }

        When(<span style="color:#e6db74">&#34;an exception is thrown by the ResourceParserDelegate&#34;</span>) {
            every { mockResourceParserDelegate.parseResource(fakeResource) } throws RuntimeException(
                <span style="color:#e6db74">&#34;Error&#34;</span>
            )
            Then(<span style="color:#e6db74">&#34;it is propagated to the caller&#34;</span>) {
                shouldThrow&lt;RuntimeException&gt; {
                    objectInTest.parseResource(mockResourceParserDelegate, fakeResource)
                }
            }
        }
    }
})
</code></pre></div><p>In the Kotest version, you can no longer make use of annotations for initialising your mocks (as supported by popular mocking libraries, such as <a href="https://mockk.io/">mockk</a> and <a href="https://site.mockito.org/">mockito</a>). This is because the test is written in a lambda that is passed as a parameter in the BehaviorSpec constructor.Therefore, annoatations cannot be used for this purpose (at least with mockk, although this will also be the case for other libraries as well). The object in test is initialised before any containers are initialised (using a <code>beforeContainer</code> block), as in the previous case. The two tests share no common initialisation code (apart from a common variable), and there is no need to add another <code>beforeContainer</code> before the two <code>When</code> blocks. The <code>arrange-related</code> statements are placed at the beginning of the <code>When</code> blocks. In the first test, this is followed by the <code>act-related</code> statement which also stores the result, that is used inside the <code>assert-related</code> statements placed in the <code>Then</code> block. In the second test, the <code>act-related</code> and the <code>assert-related</code> statements are joined in a single <code>shouldThrow</code> block, because it tests whether an exception is thrown.</p>
<h2 id="ci-support">CI-support</h2>
<p>Kotest integrates very well with Intellij (and Android Studio) IDE, via its <a href="https://plugins.jetbrains.com/plugin/14080-kotest">official plugin</a>. However, since its structure is a radical departure from the standard JUnit format, the default JUnit report generated by the Gradle test plugin becomes unusable (the test count and the test names are wrong). This may be irrelevant when running your tests locally - it completely breaks potential (or current) CI integrations you may have. To overcome this limitation, the Kotest framework offers the <a href="https://kotest.io/docs/extensions/junit_xml.html">JUnit XML</a> extension, which writes a separate report file that correctly reports the tests executed and their results.</p>
<p>To set it up, you need to add the following line to your module&rsquo;s build gradle ($kotestVersion refers to the kotest version you use in your project):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">testImplementation <span style="color:#e6db74">&#34;io.kotest:kotest-extensions-junitxml:$kotestVersion&#34;</span>
</code></pre></div><p>To use the extension, you will need to create a subclass (either a class or object will do) of the <code>AbstractProjectConfig</code> class, which is automatically used by Kotest to configure the overall test project. You can see all available configuration options <a href="https://kotest.io/docs/framework/project-config.html">here</a>. In the subclass, you override the <code>listeners</code> function such that it returns a list with a new instance of the <code>JunitXmlReporter</code>. The subclass can reside anywhere in your test source set - Kotest will find and use it. An example is the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">object</span> <span style="color:#a6e22e">MyKotestProjectConfig</span> : AbstractProjectConfig() {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">listeners</span>(): List&lt;Listener&gt; = listOf(
        JunitXmlReporter(
            includeContainers = <span style="color:#66d9ef">false</span>,
            useTestPathAsName = <span style="color:#66d9ef">true</span>
        )
    )
}
</code></pre></div><p>The constructor of the <code>JunitXmlReporter</code> takes two parameters:</p>
<ul>
<li>includeContainers - a boolean which indicates whether the XML report will include intermediate containers as separate line entries, not just <code>Then</code> blocks. Defaults to <code>false</code>. When set to <code>true</code>, it artificially increases the number of tests included (without much benefit).</li>
<li>useTestPathAsName - a boolean which indicates whether the name of the test in the report will include the complete path (the sequence of <code>Given</code>, <code>When</code>, <code>And</code>, <code>Then</code>) of the test, or just the final <code>Then</code> block. This defaults to <code>true</code>. When set to <code>false</code>, all test names will only include the leaf-<code>Then</code> blocks names.</li>
</ul>
<p>After running your tests, the correct JUnit XML reports (and only those, not the HTML report) will be found in your module&rsquo;s build directory, under the <code>test-results/test</code> subfolder. Note that the default, incorrect XML version of the test results <strong>will also</strong> be available under the <code>test-results/testXYZUnitText</code> (XYZ being the combination of flavor/build type used in running the tests).</p>
<p>Example code demonstrating the usage of the JUnit XML extension can be found <a href="https://github.com/gmetal/metador/commit/6ebbfcff67a27542363d9d2b5e7f8d91866c0346">here</a>.</p>
]]></content>
        </item>
        
        <item>
            <title>Adding documentation to a kotlin project with Dokka </title>
            <link>https://gmetal.dev/posts/add-documentation-with-dokka/</link>
            <pubDate>Mon, 21 Jun 2021 06:00:00 +0000</pubDate>
            
            <guid>https://gmetal.dev/posts/add-documentation-with-dokka/</guid>
            <description>Library by Geoff Coupe, licensed under CC BY-NC-SA 2.0
  Dokka is for kotlin what Javadoc is for Java. It converts your KDoc-styled comments into a variety of document format such as HTML, Markdown (Github and Jekyll forms) and Javadoc HTML.
How to add dokka to your gradle project Adding dokka to your Gradle project is very easy, as discussed in their documentation. You just add the dokka plugin to the plugins block of your module&amp;rsquo;s build gradle (not the root build.</description>
            <content type="html"><![CDATA[<figure>
    <img src="/images/20972113_ce388e201e_b.jpg"/> <figcaption>
            <p>
                    <a href="https://www.flickr.com/photos/67951361@N00/20972113">Library by Geoff Coupe, licensed under CC BY-NC-SA 2.0</a></p>
        </figcaption>
</figure>

<p><a href="https://kotlin.github.io/dokka/1.5/">Dokka</a> is for kotlin what <a href="https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html">Javadoc</a> is for Java. It converts your <a href="https://kotlinlang.org/docs/kotlin-doc.html">KDoc-styled comments</a> into a variety of document format such as HTML, Markdown (Github and Jekyll forms) and Javadoc HTML.</p>
<h2 id="how-to-add-dokka-to-your-gradle-project">How to add dokka to your gradle project</h2>
<p>Adding dokka to your Gradle project is very easy, as discussed <a href="https://kotlin.github.io/dokka/1.5/user_guide/gradle/usage/">in their documentation</a>. You just add the dokka plugin to the plugins block of your <strong>module&rsquo;s build gradle</strong> (not the root build.gradle file):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">plugins <span style="color:#f92672">{</span>
    id <span style="color:#e6db74">&#34;com.android.library&#34;</span>
    id <span style="color:#e6db74">&#34;kotlin-android&#34;</span>
    id <span style="color:#e6db74">&#34;org.jetbrains.dokka&#34;</span> version <span style="color:#e6db74">&#34;1.4.32&#34;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>and that&rsquo;s about it. The plugin will create several dokka-prefixed gradle tasks, each of which is responsible for generating the documentation in each of the supported formats.</p>
<h2 id="customising-the-dokka-configuration">Customising the dokka configuration</h2>
<p>You can tweak the configuration of each documentation task by adding the corresponding dokka-prefixed block in your module&rsquo;s <code>build.gradle</code> file. For example, if you are interested in generating the HTML documentation, then you need to add the following <code>dokkaHtml</code> block:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">dokkaHtml <span style="color:#f92672">{</span>
    moduleName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;My module&#39;s documentation&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>The above will set the overall title of the documentation for the associated (gradle) module. This is primarily displayed in the documentation&rsquo;s (HTML or Javadoc) main <code>index.html</code> page. Dokka allows you to provide different configuration options per source set:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">dokkaHtml <span style="color:#f92672">{</span>
    moduleName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;My module&#39;s documentation&#34;</span><span style="color:#f92672">)</span>

    dokkaSourceSets <span style="color:#f92672">{</span>
        configureEach <span style="color:#f92672">{</span>
            displayName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>it<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">)</span>
            suppress<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>We can replace the <code>configureEach</code> block with a specific source set name (e.g. <code>main</code>) if we are only interested in modifying the configuration of the specified source set. Multiple source sets can be configured by adding multiple blocks. So for example, if our module has a <code>main</code> and a <code>test</code> source set, we can configure them like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">dokkaHtml <span style="color:#f92672">{</span>
    moduleName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;My module&#39;s documentation&#34;</span><span style="color:#f92672">)</span>

    dokkaSourceSets <span style="color:#f92672">{</span>
        main <span style="color:#f92672">{</span>
            displayName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;main&#34;</span><span style="color:#f92672">)</span>
            suppress<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
        test <span style="color:#f92672">{</span>
            displayName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test&#34;</span><span style="color:#f92672">)</span>
            suppress<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>The <code>suppress</code> configuration option is used for including or excluding a source set.</p>
<div class="admonition note">
<p class="admonition title">Note</p>
<p>By default the <code>test</code> source set is excluded from the documentation. To enable it you have to use the <code>suppress.set(false)</code> directive in the configuration.</p>
</div>

<p>A very useful feature of any documentation engine is the addition of links in external and internal code, which can be used by developers to link their documentation internally (e.g. within their project), or externally (e.g. with the language&rsquo;s or framework&rsquo;s documentation). In <a href="https://kotlinlang.org/docs/kotlin-doc.html">KDoc</a>, this is achieved using <a href="https://kotlinlang.org/docs/kotlin-doc.html#inline-markup">Markdown syntax</a>. Any entity that is included in square brackets <code>[]</code> will be resolved as a link. The link may be an entity in the same project, or part of an external documentation.</p>
<div class="admonition important">
<p class="admonition title">Warning</p>
<p>Be careful at what tags the <a href="https://kotlinlang.org/docs/kotlin-doc.html">KDoc</a> specification supports, in order to only use the compatible ones. Although, the majority of Javadoc&rsquo;s tags (<strong>@param</strong>, <strong>@return</strong>, etc) are supported, the highly popular <strong>@link</strong> is unsupported. Links to classes are added through <a href="https://kotlinlang.org/docs/kotlin-doc.html#inline-markup">Markdown syntax</a>. This may cause some headaches, especially if you are porting a project from Java to Kotlin, and the generated documentation ignores such tags.</p>
</div>

<p>When dokka is generating the documentation, it will attempt to contact various online sources which will be used for linking to a specific entity (e.g. whether a class can be found in the Oracle JDK, or Kotlin documentation, or even the Android documentation). You can disable this functionality by using the offline mode attribute:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">dokkaHtml <span style="color:#f92672">{</span>
    moduleName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;My module&#39;s documentation&#34;</span><span style="color:#f92672">)</span>
    offlineMode<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
    dokkaSourceSets <span style="color:#f92672">{</span>
        main <span style="color:#f92672">{</span>
            displayName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;main&#34;</span><span style="color:#f92672">)</span>
            suppress<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
            includes<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;description.md&#34;</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Now, only local information will be used when resolving entities. If these entities cannot be found, then a link to them will not get generated.</p>
<div class="admonition important">
<p class="admonition title">Warning</p>
<p>To add package-level and module level documentation, you cannot use a <a href="https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/javadoc.html">package-info.java</a> file. Instead, you must create a regular markdown file with a very specific structure as discussed <a href="https://kotlinlang.org/docs/kotlin-doc.html#module-and-package-documentation">here</a>. Note that, only the first sentence of each section of this markdown file will be included in the documentation.</p>
</div>

<p>You include the markdown file with the module and package documentation, by adding the <code>includes</code> directive as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">dokkaHtml <span style="color:#f92672">{</span>
    moduleName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;My module&#39;s documentation&#34;</span><span style="color:#f92672">)</span>

    dokkaSourceSets <span style="color:#f92672">{</span>
        main <span style="color:#f92672">{</span>
            displayName<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;main&#34;</span><span style="color:#f92672">)</span>
            suppress<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
            includes<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;description.md&#34;</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>The above directive instructs Dokka to search for the <code>description.md</code> file in the directory of the corresponding gradle module, and use the <code>package</code> and <code>module</code> directives to generate the documentation accordingly.</p>
<h2 id="packaging-the-documentation">Packaging the documentation</h2>
<p>After you&rsquo;ve generated your documentation (especially your javadoc documentation), you may want to package it in a jar file and upload it to an external artifact repository, to accompany a corresponding dependency that you&rsquo;ve created. This can be achieved very easily with a simple task:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">task <span style="color:#a6e22e">javadocJar</span><span style="color:#f92672">(</span>type: Jar<span style="color:#f92672">,</span> dependsOn: dokkaJavadoc<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    group <span style="color:#e6db74">&#34;publishing&#34;</span>
    description <span style="color:#e6db74">&#34;Generates javadocJar based on Dokka&#34;</span>
    archiveClassifier<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;javadoc&#34;</span><span style="color:#f92672">)</span>
    from dokkaJavadoc<span style="color:#f92672">.</span><span style="color:#a6e22e">outputDirectory</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>The above task will take the output of the <code>dokkaJavadoc</code> task and create a jar from it. It depends on the <code>dokkaJavadoc</code> task and will run it if required. Once this task has been run, a file called: <strong>GRADLE_MODULE_NAME-javadoc.jar</strong>, will be generated in the module&rsquo;s <code>build/libs</code> folder.</p>
<h2 id="example-configuration-and-output">Example configuration and output</h2>
<p>You can find example dokka configuration in <a href="https://github.com/gmetal/metador">this repository</a>. The generated project documentation are available in <a href="/projects/metador/javadoc/index.html">Javadoc</a> and <a href="/projects/metador/html/index.html">KDoc</a> formats.</p>
]]></content>
        </item>
        
    </channel>
</rss>
